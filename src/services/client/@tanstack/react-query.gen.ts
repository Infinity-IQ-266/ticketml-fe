// This file is auto-generated by @hey-api/openapi-ts
import {
    type DefaultError,
    type InfiniteData,
    type UseMutationOptions,
    infiniteQueryOptions,
    queryOptions,
} from '@tanstack/react-query';
import type { AxiosError } from 'axios';

import { client } from '../client.gen';
import {
    type Options,
    addTicketTypeToEvent,
    checkInTicket,
    createEvent,
    createOrder,
    createOrganization,
    getAllEvents,
    getCurrentUser,
    getEventById,
    getEventsByOrganization,
    getMyOrderHistory,
    getMyOrganizations,
    getTickets,
    handleChatMessage,
    handleVnpayIpn,
    updateEvent,
    updateOrganization,
    updateProfile,
    updateTicketType,
    upload,
} from '../sdk.gen';
import type {
    AddTicketTypeToEventData,
    AddTicketTypeToEventResponse,
    CheckInTicketData,
    CheckInTicketResponse,
    CreateEventData,
    CreateEventResponse,
    CreateOrderData,
    CreateOrderResponse,
    CreateOrganizationData,
    CreateOrganizationResponse,
    GetAllEventsData,
    GetAllEventsResponse,
    GetCurrentUserData,
    GetEventByIdData,
    GetEventsByOrganizationData,
    GetMyOrderHistoryData,
    GetMyOrganizationsData,
    GetTicketsData,
    HandleChatMessageData,
    HandleChatMessageResponse,
    HandleVnpayIpnData,
    UpdateEventData,
    UpdateEventResponse,
    UpdateOrganizationData,
    UpdateOrganizationResponse,
    UpdateProfileData,
    UpdateProfileResponse,
    UpdateTicketTypeData,
    UpdateTicketTypeResponse,
    UploadData,
    UploadResponse,
} from '../types.gen';

export type QueryKey<TOptions extends Options> = [
    Pick<TOptions, 'baseURL' | 'body' | 'headers' | 'path' | 'query'> & {
        _id: string;
        _infinite?: boolean;
        tags?: ReadonlyArray<string>;
    },
];

const createQueryKey = <TOptions extends Options>(
    id: string,
    options?: TOptions,
    infinite?: boolean,
    tags?: ReadonlyArray<string>,
): [QueryKey<TOptions>[0]] => {
    const params: QueryKey<TOptions>[0] = {
        _id: id,
        baseURL:
            options?.baseURL || (options?.client ?? client).getConfig().baseURL,
    } as QueryKey<TOptions>[0];
    if (infinite) {
        params._infinite = infinite;
    }
    if (tags) {
        params.tags = tags;
    }
    if (options?.body) {
        params.body = options.body;
    }
    if (options?.headers) {
        params.headers = options.headers;
    }
    if (options?.path) {
        params.path = options.path;
    }
    if (options?.query) {
        params.query = options.query;
    }
    return [params];
};

export const getCurrentUserQueryKey = (options?: Options<GetCurrentUserData>) =>
    createQueryKey('getCurrentUser', options);

export const getCurrentUserOptions = (
    options?: Options<GetCurrentUserData>,
) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getCurrentUser({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: getCurrentUserQueryKey(options),
    });
};

export const updateProfileMutation = (
    options?: Partial<Options<UpdateProfileData>>,
): UseMutationOptions<
    UpdateProfileResponse,
    AxiosError<DefaultError>,
    Options<UpdateProfileData>
> => {
    const mutationOptions: UseMutationOptions<
        UpdateProfileResponse,
        AxiosError<DefaultError>,
        Options<UpdateProfileData>
    > = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateProfile({
                ...options,
                ...fnOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const updateOrganizationMutation = (
    options?: Partial<Options<UpdateOrganizationData>>,
): UseMutationOptions<
    UpdateOrganizationResponse,
    AxiosError<DefaultError>,
    Options<UpdateOrganizationData>
> => {
    const mutationOptions: UseMutationOptions<
        UpdateOrganizationResponse,
        AxiosError<DefaultError>,
        Options<UpdateOrganizationData>
    > = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateOrganization({
                ...options,
                ...fnOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const uploadMutation = (
    options?: Partial<Options<UploadData>>,
): UseMutationOptions<
    UploadResponse,
    AxiosError<DefaultError>,
    Options<UploadData>
> => {
    const mutationOptions: UseMutationOptions<
        UploadResponse,
        AxiosError<DefaultError>,
        Options<UploadData>
    > = {
        mutationFn: async (fnOptions) => {
            const { data } = await upload({
                ...options,
                ...fnOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const getMyOrganizationsQueryKey = (
    options?: Options<GetMyOrganizationsData>,
) => createQueryKey('getMyOrganizations', options);

export const getMyOrganizationsOptions = (
    options?: Options<GetMyOrganizationsData>,
) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getMyOrganizations({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: getMyOrganizationsQueryKey(options),
    });
};

export const createOrganizationMutation = (
    options?: Partial<Options<CreateOrganizationData>>,
): UseMutationOptions<
    CreateOrganizationResponse,
    AxiosError<DefaultError>,
    Options<CreateOrganizationData>
> => {
    const mutationOptions: UseMutationOptions<
        CreateOrganizationResponse,
        AxiosError<DefaultError>,
        Options<CreateOrganizationData>
    > = {
        mutationFn: async (fnOptions) => {
            const { data } = await createOrganization({
                ...options,
                ...fnOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const getEventsByOrganizationQueryKey = (
    options: Options<GetEventsByOrganizationData>,
) => createQueryKey('getEventsByOrganization', options);

export const getEventsByOrganizationOptions = (
    options: Options<GetEventsByOrganizationData>,
) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getEventsByOrganization({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: getEventsByOrganizationQueryKey(options),
    });
};

export const createEventMutation = (
    options?: Partial<Options<CreateEventData>>,
): UseMutationOptions<
    CreateEventResponse,
    AxiosError<DefaultError>,
    Options<CreateEventData>
> => {
    const mutationOptions: UseMutationOptions<
        CreateEventResponse,
        AxiosError<DefaultError>,
        Options<CreateEventData>
    > = {
        mutationFn: async (fnOptions) => {
            const { data } = await createEvent({
                ...options,
                ...fnOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const addTicketTypeToEventMutation = (
    options?: Partial<Options<AddTicketTypeToEventData>>,
): UseMutationOptions<
    AddTicketTypeToEventResponse,
    AxiosError<DefaultError>,
    Options<AddTicketTypeToEventData>
> => {
    const mutationOptions: UseMutationOptions<
        AddTicketTypeToEventResponse,
        AxiosError<DefaultError>,
        Options<AddTicketTypeToEventData>
    > = {
        mutationFn: async (fnOptions) => {
            const { data } = await addTicketTypeToEvent({
                ...options,
                ...fnOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const checkInTicketMutation = (
    options?: Partial<Options<CheckInTicketData>>,
): UseMutationOptions<
    CheckInTicketResponse,
    AxiosError<DefaultError>,
    Options<CheckInTicketData>
> => {
    const mutationOptions: UseMutationOptions<
        CheckInTicketResponse,
        AxiosError<DefaultError>,
        Options<CheckInTicketData>
    > = {
        mutationFn: async (fnOptions) => {
            const { data } = await checkInTicket({
                ...options,
                ...fnOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const createOrderMutation = (
    options?: Partial<Options<CreateOrderData>>,
): UseMutationOptions<
    CreateOrderResponse,
    AxiosError<DefaultError>,
    Options<CreateOrderData>
> => {
    const mutationOptions: UseMutationOptions<
        CreateOrderResponse,
        AxiosError<DefaultError>,
        Options<CreateOrderData>
    > = {
        mutationFn: async (fnOptions) => {
            const { data } = await createOrder({
                ...options,
                ...fnOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const handleChatMessageMutation = (
    options?: Partial<Options<HandleChatMessageData>>,
): UseMutationOptions<
    HandleChatMessageResponse,
    AxiosError<DefaultError>,
    Options<HandleChatMessageData>
> => {
    const mutationOptions: UseMutationOptions<
        HandleChatMessageResponse,
        AxiosError<DefaultError>,
        Options<HandleChatMessageData>
    > = {
        mutationFn: async (fnOptions) => {
            const { data } = await handleChatMessage({
                ...options,
                ...fnOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const updateTicketTypeMutation = (
    options?: Partial<Options<UpdateTicketTypeData>>,
): UseMutationOptions<
    UpdateTicketTypeResponse,
    AxiosError<DefaultError>,
    Options<UpdateTicketTypeData>
> => {
    const mutationOptions: UseMutationOptions<
        UpdateTicketTypeResponse,
        AxiosError<DefaultError>,
        Options<UpdateTicketTypeData>
    > = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateTicketType({
                ...options,
                ...fnOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const updateEventMutation = (
    options?: Partial<Options<UpdateEventData>>,
): UseMutationOptions<
    UpdateEventResponse,
    AxiosError<DefaultError>,
    Options<UpdateEventData>
> => {
    const mutationOptions: UseMutationOptions<
        UpdateEventResponse,
        AxiosError<DefaultError>,
        Options<UpdateEventData>
    > = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateEvent({
                ...options,
                ...fnOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const getTicketsQueryKey = (options?: Options<GetTicketsData>) =>
    createQueryKey('getTickets', options);

export const getTicketsOptions = (options?: Options<GetTicketsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getTickets({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: getTicketsQueryKey(options),
    });
};

export const getMyOrderHistoryQueryKey = (
    options?: Options<GetMyOrderHistoryData>,
) => createQueryKey('getMyOrderHistory', options);

export const getMyOrderHistoryOptions = (
    options?: Options<GetMyOrderHistoryData>,
) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getMyOrderHistory({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: getMyOrderHistoryQueryKey(options),
    });
};

export const handleVnpayIpnQueryKey = (options?: Options<HandleVnpayIpnData>) =>
    createQueryKey('handleVnpayIpn', options);

export const handleVnpayIpnOptions = (
    options?: Options<HandleVnpayIpnData>,
) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await handleVnpayIpn({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: handleVnpayIpnQueryKey(options),
    });
};

export const getAllEventsQueryKey = (options?: Options<GetAllEventsData>) =>
    createQueryKey('getAllEvents', options);

export const getAllEventsOptions = (options?: Options<GetAllEventsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getAllEvents({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: getAllEventsQueryKey(options),
    });
};

const createInfiniteParams = <
    K extends Pick<QueryKey<Options>[0], 'body' | 'headers' | 'path' | 'query'>,
>(
    queryKey: QueryKey<Options>,
    page: K,
) => {
    const params = {
        ...queryKey[0],
    };
    if (page.body) {
        params.body = {
            ...(queryKey[0].body as any),
            ...(page.body as any),
        };
    }
    if (page.headers) {
        params.headers = {
            ...queryKey[0].headers,
            ...page.headers,
        };
    }
    if (page.path) {
        params.path = {
            ...(queryKey[0].path as any),
            ...(page.path as any),
        };
    }
    if (page.query) {
        params.query = {
            ...(queryKey[0].query as any),
            ...(page.query as any),
        };
    }
    return params as unknown as typeof page;
};

export const getAllEventsInfiniteQueryKey = (
    options?: Options<GetAllEventsData>,
): QueryKey<Options<GetAllEventsData>> =>
    createQueryKey('getAllEvents', options, true);

export const getAllEventsInfiniteOptions = (
    options?: Options<GetAllEventsData>,
) => {
    return infiniteQueryOptions<
        GetAllEventsResponse,
        AxiosError<DefaultError>,
        InfiniteData<GetAllEventsResponse>,
        QueryKey<Options<GetAllEventsData>>,
        | number
        | Pick<
              QueryKey<Options<GetAllEventsData>>[0],
              'body' | 'headers' | 'path' | 'query'
          >
    >(
        // @ts-ignore
        {
            queryFn: async ({ pageParam, queryKey, signal }) => {
                // @ts-ignore
                const page: Pick<
                    QueryKey<Options<GetAllEventsData>>[0],
                    'body' | 'headers' | 'path' | 'query'
                > =
                    typeof pageParam === 'object'
                        ? pageParam
                        : {
                              query: {
                                  page: pageParam,
                              },
                          };
                const params = createInfiniteParams(queryKey, page);
                const { data } = await getAllEvents({
                    ...options,
                    ...params,
                    signal,
                    throwOnError: true,
                });
                return data;
            },
            queryKey: getAllEventsInfiniteQueryKey(options),
        },
    );
};

export const getEventByIdQueryKey = (options: Options<GetEventByIdData>) =>
    createQueryKey('getEventById', options);

export const getEventByIdOptions = (options: Options<GetEventByIdData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getEventById({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: getEventByIdQueryKey(options),
    });
};
